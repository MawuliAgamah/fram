"""
Parse LLM responses into structured agent decisions.

The expected output format is::

    <reasoning text> | <integer action index>

The parser is deliberately lenient — it strips whitespace, handles extra
pipes in the reasoning, tries regex extraction if a simple split fails,
and falls back to index 0 (STAY) on any failure.  The simulation never
crashes because of a bad API response.
"""

from __future__ import annotations

import logging
import re
from dataclasses import dataclass

from swarm.core.world import Position

logger = logging.getLogger(__name__)


@dataclass
class LLMDecision:
    """Parsed result of a single LLM decision call."""

    chosen_position: Position
    chosen_index: int
    reasoning: str
    raw_response: str
    parse_success: bool = True


# ── Extraction helpers ───────────────────────────────────────────────

# Match a trailing integer (possibly after a pipe) at the end of the text.
_TRAILING_INDEX_RE = re.compile(r"\|\s*(\d+)\s*$")
# Fallback: any isolated integer in the response.
_ANY_INT_RE = re.compile(r"\b(\d+)\b")


def _extract_reasoning_and_index(text: str) -> tuple[str, int | None]:
    """Split ``text`` into (reasoning, index).

    Strategy:
    1. Split on the *last* ``|`` character — everything before is reasoning,
       everything after is the index.
    2. If (1) fails, search for a trailing integer with regex.
    3. If nothing works, return (full text, None).
    """
    text = text.strip()

    # Strategy 1: rsplit on last pipe
    if "|" in text:
        reasoning_part, _, index_part = text.rpartition("|")
        index_part = index_part.strip()
        if index_part.isdigit():
            return reasoning_part.strip(), int(index_part)

    # Strategy 2: trailing integer after pipe (regex)
    m = _TRAILING_INDEX_RE.search(text)
    if m:
        idx = int(m.group(1))
        reasoning = text[: m.start()].strip()
        return reasoning, idx

    # Strategy 3: any lone integer in the text
    m = _ANY_INT_RE.search(text)
    if m:
        return text, int(m.group(1))

    return text, None


# ── Main parser ──────────────────────────────────────────────────────


def parse_llm_response(
    response_text: str,
    available: list[Position],
    fallback: Position | None = None,
) -> LLMDecision:
    """Parse an LLM ``reasoning | index`` response into an ``LLMDecision``.

    Parameters
    ----------
    response_text:
        Raw text from the LLM.
    available:
        Ordered list of positions corresponding to index 0, 1, 2, …
        (as generated by ``get_available_moves``).
    fallback:
        Position to use if parsing fails entirely.  Defaults to
        ``available[0]`` (STAY).

    Returns
    -------
    LLMDecision
        Always returns a decision (never raises).  Check ``.parse_success``
        to know whether the response was cleanly parsed.
    """
    fb = fallback or (available[0] if available else Position(0, 0))

    reasoning, index = _extract_reasoning_and_index(response_text)

    if index is not None and 0 <= index < len(available):
        return LLMDecision(
            chosen_position=available[index],
            chosen_index=index,
            reasoning=reasoning,
            raw_response=response_text,
            parse_success=True,
        )

    # Index out of range
    if index is not None:
        logger.warning(
            "LLM returned index %d but only %d actions available — falling back",
            index,
            len(available),
        )
    else:
        logger.warning("Could not extract action index from LLM response — falling back")

    return LLMDecision(
        chosen_position=fb,
        chosen_index=0,
        reasoning=f"[fallback] {reasoning}",
        raw_response=response_text,
        parse_success=False,
    )
